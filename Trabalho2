package trabalhoDois;
import java.util.*;
import java.io.*;

public class OrdenaçãoComparativa {
	static class Contador {
		int comparacoes = 0;
		int trocas = 0;
	}

	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		while (true) {
			int[] vetorOriginal = new int[8];
			boolean entradaValida = true;

			System.out.println("\nDigite 8 números inteiros POSITIVOS e PARES:");

			for (int i = 0; i < 8; i++) {
				System.out.print("Número " + (i + 1) + ": ");
				int num = scanner.nextInt();
				if (num <= 0) {
					System.out.println("AVISO: O número inserido não é positivo. O programa será reiniciado.");
					entradaValida = false;
					break;
				}
				if (num % 2 != 0) {
					System.out.println("AVISO: O numero inserido nao é par. O programa será reiniciado.");
					entradaValida = false;
					break;
				}
				vetorOriginal[i] = num;
			}
			if (!entradaValida) {
				continue;
			}
			System.out.println("\nEntrada aceita! Prosseguindo com a ordenação...");

			// Cópias dos vetores
			// Cria cópias independentes do vetor original para cada algoritmo.
			// Isso garante que todos os algoritmos ordenem a mesma lista desordenada.
			int[] vetorSelection = vetorOriginal.clone();
			int[] vetorQuick = vetorOriginal.clone();
			int[] vetorMerge = vetorOriginal.clone();

			// Cria um objeto Contador para cada algoritmo para rastrear suas métricas
			// separadamente.
			Contador cSelection = new Contador();
			Contador cQuick = new Contador();
			Contador cMerge = new Contador();

			// Aplicando ordenações chamando a cada método de ordenação, passando o vetor a
			// ser ordenado e seu respectivo contador.
			selectionSort(vetorSelection, cSelection);
			quickSort(vetorQuick, 0, vetorQuick.length - 1, cQuick);
			mergeSort(vetorMerge, 0, vetorMerge.length - 1, cMerge);

			// Exibindo no terminal
			System.out.println("\nVetor original: " + Arrays.toString(vetorOriginal));
			exibirResultado("Selection Sort", vetorSelection, cSelection);
			exibirResultado("Quick Sort", vetorQuick, cQuick);
			exibirResultado("Merge Sort", vetorMerge, cMerge);

			// Exportar para arquivo
			try {
				PrintWriter writer = new PrintWriter("resultado.txt");

				writer.println("Vetor original: " + Arrays.toString(vetorOriginal));
				salvarResultado(writer, "Selection Sort", vetorSelection, cSelection);
				salvarResultado(writer, "Quick Sort", vetorQuick, cQuick);
				salvarResultado(writer, "Merge Sort", vetorMerge, cMerge);

				writer.close();
				System.out.println("\nResultados exportados para 'resultado.txt'.");
			} catch (IOException e) {
				System.out.println("Erro ao salvar o arquivo: " + e.getMessage());
			}

			break;

		}

		scanner.close();
	}

	// exibi os resultados no console
	public static void exibirResultado(String nome, int[] vetor, Contador c) {
		System.out.println("\nAlgoritmo: " + nome);
		System.out.println("Vetor ordenado: " + Arrays.toString(vetor));
		System.out.println("Total de comparações: " + c.comparacoes);
		System.out.println("Total de trocas: " + c.trocas);
	}

	// salvar os resultados de um algoritmo em um arquivo.
	public static void salvarResultado(PrintWriter writer, String nome, int[] vetor, Contador c) {
		writer.println("\nAlgoritmo: " + nome);
		writer.println("Vetor ordenado: " + Arrays.toString(vetor));
		writer.println("Total de comparações: " + c.comparacoes);
		writer.println("Total de trocas: " + c.trocas);
	}

	// Algoritmo Selection Sort: a cada iteração, encontra o menor elemento na
	// porção não ordenada e o move para a posição correta.
	public static void selectionSort(int[] v, Contador c) {
		int n = v.length; // tamanho
		// percorre o vetor para posicionar corretamente
		for (int i = 0; i < n - 1; i++) {
			int min = i;// o atual é o menor
			// percorre procurando o menor no restante
			for (int j = i + 1; j < n; j++) {
				c.comparacoes++; // add a cada comparação
				if (v[j] < v[min]) {
					min = j; // atualiza o indice do menor encontrado
				}
			}
			// menor encontrado em posição diferente da atual
			if (i != min) {
				// troca
				int temp = v[i];
				v[i] = v[min];
				v[min] = temp;
				// somamos 2 ao contador, pois numa troca de dois vetores contabilizamos duas trocas de posição e nao uma
				c.trocas += 2;
			}
		}
	}

	// Algoritmo Quick Sort: dividir para conquistar
	// parada da recursão: continua apenas se o subvetor tiver mais de um elemento.
	public static void quickSort(int[] v, int ini, int fim, Contador c) {
		if (ini < fim) {
			int pi = particionar(v, ini, fim, c);
			quickSort(v, ini, pi - 1, c);
			quickSort(v, pi + 1, fim, c);
		}
	}

	// reorganiza o vetor de forma que elementos menores que o pivô fiquem à sua
	// esquerda e maiores fiquem à sua direita.
	private static int particionar(int[] v, int ini, int fim, Contador c) {
		int pivo = v[fim];
		int i = ini - 1; // menor elemento

		// percorre comparando com o pivo
		for (int j = ini; j < fim; j++) {
			c.comparacoes++;
			if (v[j] < pivo) {
				i++;
				trocar(v, i, j, c);
			}
		}

		// add o pivo na sua posição correta
		trocar(v, i + 1, fim, c);
		return i + 1; // posição final do pivô.
	}

	// troca dois elementos de posição no vetor
	private static void trocar(int[] v, int i, int j, Contador c) {
		if (i != j) {
			int temp = v[i];
			v[i] = v[j];
			v[j] = temp;
			c.trocas++;
		}
	}

	// Algoritmo Merge Sort: dividir para conquistar
	// parada da recursão: continua se o subvetor tiver mais de um elemento.
	public static void mergeSort(int[] v, int esq, int dir, Contador c) {
		if (esq < dir) {
			int meio = (esq + dir) / 2;
			mergeSort(v, esq, meio, c);
			mergeSort(v, meio + 1, dir, c);
			intercalar(v, esq, meio, dir, c);
		}
	}

	// intercala dois subvetores ordenados em um único vetor ordenado.
	private static void intercalar(int[] v, int esq, int meio, int dir, Contador c) {
		// calcula tamanho
		int n1 = meio - esq + 1;
		int n2 = dir - meio;

		// cria vetores temporarios p/ arm. os dados
		int[] L = new int[n1];
		int[] R = new int[n2];

		// copia os dados para os vetores temporarios
		for (int i = 0; i < n1; i++)
			L[i] = v[esq + i];
		for (int j = 0; j < n2; j++)
			R[j] = v[meio + 1 + j];

		int i = 0, j = 0, k = esq;

		// mescla os vetores L e R de volta no vetor v.
		while (i < n1 && j < n2) {
			c.comparacoes++; // Incrementa a cada comparação entre elementos de L e R.
			// Se o elemento de L for menor ou igual, ele vai para o vetor principal.
			if (L[i] <= R[j]) {
				v[k++] = L[i++];// vai pro vetor principal
			} else {
				v[k++] = R[j++];
				// ocorre "troca" ou "inversão" cada vez que um elemento da direita é movido
				// antes de um da esquerda.
				c.trocas++;
			}
		}

		// se sobra em L, copia para v
		while (i < n1)
			v[k++] = L[i++];
		// se sobra em R, copia para v
		while (j < n2)
			v[k++] = R[j++];
	}
}
